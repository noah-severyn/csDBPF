using Microsoft.VisualStudio.TestTools.UnitTesting;
using System;
using csDBPF;
using csDBPF.Properties;
using System.Xml.Linq;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Diagnostics;

namespace csDBPF_Test {
	[TestClass]
	public class DBPFUnitTests {
		internal class TestArrays {
			//Sample data from z_DataView - Parks Aura.dat --- in BINARY encoding ---
			public static byte[] notcompresseddata_b = new byte[] { 0x14, 0x00, 0x00, 0x10, 0x50, 0x00, 0x61, 0x00, 0x72, 0x00, 0x6B, 0x00, 0x73, 0x00, 0x20, 0x00, 0x41, 0x00, 0x75, 0x00, 0x72, 0x00, 0x61, 0x00, 0x20, 0x00, 0x28, 0x00, 0x62, 0x00, 0x79, 0x00, 0x20, 0x00, 0x43, 0x00, 0x6F, 0x00, 0x72, 0x00, 0x69, 0x00, 0x29, 0x00 };
			public static byte[] compresseddata_b = new byte[] { 0x42, 0x01, 0x00, 0x00, 0x10, 0xFB, 0x00, 0x01, 0xBE, 0xE5, 0x45, 0x51, 0x5A, 0x42, 0x31, 0x23, 0x23, 0x23, 0x61, 0x28, 0x34, 0x05, 0x3F, 0x69, 0x0F, 0x69, 0x00, 0x67, 0x0B, 0x4A, 0x0F, 0x00, 0x00, 0x00, 0x01, 0x03, 0x10, 0x02, 0x03, 0x00, 0x03, 0x01, 0x03, 0x23, 0x05, 0x0C, 0x20, 0xE0, 0x0C, 0x80, 0x00, 0x00, 0x01, 0x07, 0x14, 0xE5, 0x44, 0x61, 0x74, 0x61, 0x56, 0x69, 0x65, 0x77, 0x3A, 0x20, 0x50, 0x61, 0x72, 0x6B, 0x73, 0x20, 0x41, 0x75, 0x72, 0x61, 0xE0, 0x47, 0x0B, 0x4A, 0x02, 0x20, 0x00, 0x03, 0x05, 0x29, 0x08, 0x9B, 0x00, 0x00, 0x05, 0x2C, 0xE1, 0x01, 0x08, 0x0B, 0x16, 0x09, 0x01, 0xE2, 0x0A, 0x40, 0x00, 0xE3, 0x10, 0x20, 0x15, 0x4D, 0xE4, 0x19, 0x33, 0x1C, 0x03, 0x05, 0x99, 0x70, 0x01, 0xE0, 0x3C, 0x53, 0xBC, 0x70, 0x11, 0x07, 0x0C, 0x01, 0x07, 0x0D, 0xE0, 0x79, 0x8C, 0xD9, 0x70, 0x11, 0x07, 0x46, 0x01, 0x07, 0x7F, 0xE0, 0xBA, 0xC5, 0xF0, 0x70, 0x00, 0x36, 0xE0, 0x00, 0xFF, 0xFF, 0xFF, 0x02, 0x07, 0x70, 0x81, 0xE0, 0xDD, 0xF1, 0xE2, 0x70, 0x01, 0x07, 0xB8, 0xE0, 0xBB, 0xE3, 0xC5, 0x70, 0x01, 0x07, 0xB9, 0xE0, 0x9A, 0xD4, 0xA8, 0x70, 0x05, 0x2F, 0xF2, 0xE0, 0xC6, 0x8A, 0x70, 0xF3, 0x00, 0x07, 0xE0, 0x58, 0xB7, 0x6A, 0x70, 0x01, 0x07, 0xFE, 0xE0, 0x36, 0xA8, 0x46, 0x70, 0x09, 0x66, 0xFF, 0x17, 0x89, 0x00, 0x70, 0xE5, 0x04, 0x68, 0x19, 0xAA, 0xE7, 0x15, 0x16, 0xE9, 0x01, 0x03, 0x06, 0x15, 0x0C, 0xEC, 0x01, 0x03, 0x64, 0x19, 0xBA, 0xEF, 0x00, 0x76, 0x15, 0xBA, 0xF2, 0x0D, 0xB6, 0x09, 0xE2, 0x99, 0x3B, 0x55, 0xBA, 0x99, 0x64, 0x83, 0xC8, 0x99, 0x7C, 0xA3, 0xC6, 0x01, 0x1F, 0x99, 0xE2, 0x99, 0x81, 0xB6, 0xB4, 0x99, 0x72, 0xBA, 0x94, 0x99, 0x4E, 0xB1, 0x65, 0x01, 0x6E, 0x99, 0x88, 0x80, 0x30, 0x99, 0xF3, 0xE8, 0x33, 0x72, 0x3E, 0x1C, 0x98, 0x3C, 0xAB, 0xB5, 0x9F, 0xDE, 0xD7, 0xC2, 0x88, 0xB1, 0xD1, 0x84, 0xFA, 0x44, 0x28, 0x16, 0xF1, 0x9F, 0x73, 0xB1, 0x5D, 0x99, 0x4E, 0x4F, 0x43, 0xD1, 0x97, 0x14, 0xA1, 0x35, 0x54, 0xF6, 0x15, 0x6E, 0xF4, 0xE0, 0xB4, 0x75, 0xCA, 0x39, 0xFC };
			public static byte[] decompresseddata_b = new byte[] { 0x45, 0x51, 0x5A, 0x42, 0x31, 0x23, 0x23, 0x23, 0x61, 0x28, 0x34, 0x05, 0x3F, 0x69, 0x0F, 0x69, 0x00, 0x67, 0x0B, 0x4A, 0x0F, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x23, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x80, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x44, 0x61, 0x74, 0x61, 0x56, 0x69, 0x65, 0x77, 0x3A, 0x20, 0x50, 0x61, 0x72, 0x6B, 0x73, 0x20, 0x41, 0x75, 0x72, 0x61, 0xE0, 0x47, 0x0B, 0x4A, 0x00, 0x03, 0x80, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE1, 0x47, 0x0B, 0x4A, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x01, 0xE2, 0x47, 0x0B, 0x4A, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x00, 0xE3, 0x47, 0x0B, 0x4A, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE4, 0x47, 0x0B, 0x4A, 0x00, 0x03, 0x80, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x99, 0x70, 0x01, 0x00, 0x00, 0x00, 0x3C, 0x53, 0xBC, 0x70, 0x0C, 0x00, 0x00, 0x00, 0x3C, 0x53, 0xBC, 0x70, 0x0D, 0x00, 0x00, 0x00, 0x79, 0x8C, 0xD9, 0x70, 0x46, 0x00, 0x00, 0x00, 0x79, 0x8C, 0xD9, 0x70, 0x7F, 0x00, 0x00, 0x00, 0xBA, 0xC5, 0xF0, 0x70, 0x80, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x70, 0x81, 0x00, 0x00, 0x00, 0xDD, 0xF1, 0xE2, 0x70, 0xB8, 0x00, 0x00, 0x00, 0xBB, 0xE3, 0xC5, 0x70, 0xB9, 0x00, 0x00, 0x00, 0x9A, 0xD4, 0xA8, 0x70, 0xF2, 0x00, 0x00, 0x00, 0x79, 0xC6, 0x8A, 0x70, 0xF3, 0x00, 0x00, 0x00, 0x58, 0xB7, 0x6A, 0x70, 0xFE, 0x00, 0x00, 0x00, 0x36, 0xA8, 0x46, 0x70, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x99, 0x00, 0x70, 0xE5, 0x47, 0x0B, 0x4A, 0x00, 0x03, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0xE7, 0x47, 0x0B, 0x4A, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x01, 0xE9, 0x47, 0x0B, 0x4A, 0x00, 0x03, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0xEC, 0x47, 0x0B, 0x4A, 0x00, 0x03, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 0xEF, 0x47, 0x0B, 0x4A, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xF2, 0x47, 0x0B, 0x4A, 0x00, 0x03, 0x80, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x99, 0x99, 0x3B, 0x55, 0xBA, 0x99, 0x64, 0x83, 0xC8, 0x99, 0x7C, 0xA3, 0xC6, 0x99, 0xFF, 0xFF, 0xFF, 0x99, 0x81, 0xB6, 0xB4, 0x99, 0x72, 0xBA, 0x94, 0x99, 0x4E, 0xB1, 0x65, 0x99, 0x00, 0x99, 0x00, 0x99, 0xF3, 0x47, 0x0B, 0x4A, 0x00, 0x03, 0x80, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x33, 0x72, 0x3E, 0x1C, 0x98, 0x3C, 0xAB, 0xB5, 0x9F, 0xDE, 0xD7, 0xC2, 0x88, 0xB1, 0xD1, 0x84, 0xFA, 0x44, 0x28, 0x16, 0xF1, 0x9F, 0x73, 0xB1, 0x5D, 0x99, 0x4E, 0x4F, 0x43, 0xD1, 0x97, 0x14, 0xA1, 0x35, 0x54, 0xF6, 0xF4, 0x47, 0x0B, 0x4A, 0x00, 0x03, 0x00, 0x00, 0x00, 0xB4, 0x75, 0xCA, 0x39 };

			//Sample data from b62-albertsons_60s v 1.1-0x6534284a-0xd3a3e650-0xd4ebfbfa.SC4Desc --- in TEXT encoding ---
			public static byte[] notcompresseddata_t = { 0x45, 0x51, 0x5A, 0x54, 0x31, 0x23, 0x23, 0x23, 0x0D, 0x0A, 0x50, 0x61, 0x72, 0x65, 0x6E, 0x74, 0x43, 0x6F, 0x68, 0x6F, 0x72, 0x74, 0x3D, 0x4B, 0x65, 0x79, 0x3A, 0x7B, 0x30, 0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x2C, 0x30, 0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x2C, 0x30, 0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x7D, 0x0D, 0x0A, 0x50, 0x72, 0x6F, 0x70, 0x43, 0x6F, 0x75, 0x6E, 0x74, 0x3D, 0x30, 0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x38, 0x0D, 0x0A, 0x30, 0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x30, 0x3A, 0x7B, 0x22, 0x45, 0x78, 0x65, 0x6D, 0x70, 0x6C, 0x61, 0x72, 0x20, 0x54, 0x79, 0x70, 0x65, 0x22, 0x7D, 0x3D, 0x55, 0x69, 0x6E, 0x74, 0x33, 0x32, 0x3A, 0x30, 0x3A, 0x7B, 0x30, 0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x32, 0x7D, 0x0D, 0x0A, 0x30, 0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x32, 0x30, 0x3A, 0x7B, 0x22, 0x45, 0x78, 0x65, 0x6D, 0x70, 0x6C, 0x61, 0x72, 0x20, 0x4E, 0x61, 0x6D, 0x65, 0x22, 0x7D, 0x3D, 0x53, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x3A, 0x31, 0x3A, 0x7B, 0x22, 0x42, 0x36, 0x32, 0x2D, 0x43, 0x53, 0x24, 0x5F, 0x41, 0x6C, 0x62, 0x65, 0x72, 0x74, 0x73, 0x6F, 0x6E, 0x73, 0x5F, 0x36, 0x30, 0x73, 0x5F, 0x47, 0x72, 0x6F, 0x63, 0x65, 0x72, 0x79, 0x20, 0x76, 0x20, 0x31, 0x2E, 0x31, 0x22, 0x7D, 0x0D, 0x0A, 0x30, 0x78, 0x30, 0x39, 0x39, 0x41, 0x46, 0x41, 0x43, 0x44, 0x3A, 0x7B, 0x22, 0x42, 0x75, 0x6C, 0x6C, 0x64, 0x6F, 0x7A, 0x65, 0x20, 0x43, 0x6F, 0x73, 0x74, 0x22, 0x7D, 0x3D, 0x53, 0x69, 0x6E, 0x74, 0x36, 0x34, 0x3A, 0x30, 0x3A, 0x7B, 0x30, 0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x41, 0x39, 0x7D, 0x0D, 0x0A, 0x30, 0x78, 0x32, 0x37, 0x38, 0x31, 0x32, 0x38, 0x31, 0x30, 0x3A, 0x7B, 0x22, 0x4F, 0x63, 0x63, 0x75, 0x70, 0x61, 0x6E, 0x74, 0x20, 0x53, 0x69, 0x7A, 0x65, 0x22, 0x7D, 0x3D, 0x46, 0x6C, 0x6F, 0x61, 0x74, 0x33, 0x32, 0x3A, 0x33, 0x3A, 0x7B, 0x38, 0x31, 0x2E, 0x35, 0x38, 0x39, 0x37, 0x39, 0x37, 0x39, 0x37, 0x2C, 0x31, 0x33, 0x2E, 0x39, 0x34, 0x37, 0x32, 0x39, 0x39, 0x39, 0x36, 0x2C, 0x33, 0x39, 0x2E, 0x34, 0x34, 0x32, 0x35, 0x30, 0x31, 0x30, 0x37, 0x7D, 0x0D, 0x0A, 0x30, 0x78, 0x32, 0x37, 0x38, 0x31, 0x32, 0x38, 0x31, 0x31, 0x3A, 0x7B, 0x22, 0x55, 0x6E, 0x6B, 0x6E, 0x6F, 0x77, 0x6E, 0x22, 0x7D, 0x3D, 0x46, 0x6C, 0x6F, 0x61, 0x74, 0x33, 0x32, 0x3A, 0x31, 0x3A, 0x7B, 0x30, 0x2E, 0x35, 0x7D, 0x0D, 0x0A, 0x30, 0x78, 0x32, 0x37, 0x38, 0x31, 0x32, 0x38, 0x32, 0x31, 0x3A, 0x7B, 0x22, 0x52, 0x65, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x4B, 0x65, 0x79, 0x54, 0x79, 0x70, 0x65, 0x31, 0x22, 0x7D, 0x3D, 0x55, 0x69, 0x6E, 0x74, 0x33, 0x32, 0x3A, 0x33, 0x3A, 0x7B, 0x30, 0x78, 0x35, 0x41, 0x44, 0x30, 0x45, 0x38, 0x31, 0x37, 0x2C, 0x30, 0x78, 0x42, 0x32, 0x44, 0x36, 0x44, 0x45, 0x42, 0x45, 0x2C, 0x30, 0x78, 0x30, 0x30, 0x30, 0x33, 0x30, 0x30, 0x30, 0x30, 0x7D, 0x0D, 0x0A, 0x30, 0x78, 0x32, 0x37, 0x38, 0x31, 0x32, 0x38, 0x33, 0x32, 0x3A, 0x7B, 0x22, 0x57, 0x65, 0x61, 0x6C, 0x74, 0x68, 0x22, 0x7D, 0x3D, 0x55, 0x69, 0x6E, 0x74, 0x38, 0x3A, 0x30, 0x3A, 0x7B, 0x30, 0x78, 0x30, 0x31, 0x7D, 0x0D, 0x0A, 0x30, 0x78, 0x32, 0x37, 0x38, 0x31, 0x32, 0x38, 0x33, 0x33, 0x3A, 0x7B, 0x22, 0x50, 0x75, 0x72, 0x70, 0x6F, 0x73, 0x65, 0x22, 0x7D, 0x3D, 0x55, 0x69, 0x6E, 0x74, 0x38, 0x3A, 0x30, 0x3A, 0x7B, 0x30, 0x78, 0x30, 0x32, 0x7D, 0x0D, 0x0A, 0x30, 0x78, 0x32, 0x37, 0x38, 0x31, 0x32, 0x38, 0x33, 0x34, 0x3A, 0x7B, 0x22, 0x43, 0x61, 0x70, 0x61, 0x63, 0x69, 0x74, 0x79, 0x20, 0x53, 0x61, 0x74, 0x69, 0x73, 0x66, 0x69, 0x65, 0x64, 0x22, 0x7D, 0x3D, 0x55, 0x69, 0x6E, 0x74, 0x33, 0x32, 0x3A, 0x32, 0x3A, 0x7B, 0x30, 0x78, 0x30, 0x30, 0x30, 0x30, 0x33, 0x31, 0x31, 0x30, 0x2C, 0x30, 0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x32, 0x45, 0x46, 0x7D, 0x0D, 0x0A, 0x30, 0x78, 0x32, 0x37, 0x38, 0x31, 0x32, 0x38, 0x35, 0x31, 0x3A, 0x7B, 0x22, 0x50, 0x6F, 0x6C, 0x6C, 0x75, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x61, 0x74, 0x20, 0x63, 0x65, 0x6E, 0x74, 0x72, 0x65, 0x22, 0x7D, 0x3D, 0x53, 0x69, 0x6E, 0x74, 0x33, 0x32, 0x3A, 0x34, 0x3A, 0x7B, 0x30, 0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x37, 0x2C, 0x30, 0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x33, 0x2C, 0x30, 0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x36, 0x2C, 0x30, 0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x7D, 0x0D, 0x0A, 0x30, 0x78, 0x32, 0x37, 0x38, 0x31, 0x32, 0x38, 0x35, 0x34, 0x3A, 0x7B, 0x22, 0x50, 0x6F, 0x77, 0x65, 0x72, 0x20, 0x43, 0x6F, 0x6E, 0x73, 0x75, 0x6D, 0x65, 0x64, 0x22, 0x7D, 0x3D, 0x55, 0x69, 0x6E, 0x74, 0x33, 0x32, 0x3A, 0x30, 0x3A, 0x7B, 0x30, 0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x30, 0x7D, 0x0D, 0x0A, 0x30, 0x78, 0x32, 0x39, 0x32, 0x34, 0x34, 0x44, 0x42, 0x35, 0x3A, 0x7B, 0x22, 0x46, 0x6C, 0x61, 0x6D, 0x6D, 0x61, 0x62, 0x69, 0x6C, 0x69, 0x74, 0x79, 0x22, 0x7D, 0x3D, 0x55, 0x69, 0x6E, 0x74, 0x38, 0x3A, 0x30, 0x3A, 0x7B, 0x30, 0x78, 0x32, 0x44, 0x7D, 0x0D, 0x0A, 0x30, 0x78, 0x32, 0x41, 0x34, 0x39, 0x39, 0x46, 0x38, 0x35, 0x3A, 0x7B, 0x22, 0x51, 0x75, 0x65, 0x72, 0x79, 0x20, 0x65, 0x78, 0x65, 0x6D, 0x70, 0x6C, 0x61, 0x72, 0x20, 0x47, 0x55, 0x49, 0x44, 0x22, 0x7D, 0x3D, 0x55, 0x69, 0x6E, 0x74, 0x33, 0x32, 0x3A, 0x30, 0x3A, 0x7B, 0x30, 0x78, 0x43, 0x41, 0x35, 0x36, 0x37, 0x38, 0x33, 0x41, 0x7D, 0x0D, 0x0A, 0x30, 0x78, 0x32, 0x43, 0x38, 0x46, 0x38, 0x37, 0x34, 0x36, 0x3A, 0x7B, 0x22, 0x45, 0x78, 0x65, 0x6D, 0x70, 0x6C, 0x61, 0x72, 0x20, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6F, 0x72, 0x79, 0x22, 0x7D, 0x3D, 0x55, 0x69, 0x6E, 0x74, 0x33, 0x32, 0x3A, 0x30, 0x3A, 0x7B, 0x30, 0x78, 0x38, 0x43, 0x38, 0x46, 0x42, 0x42, 0x43, 0x43, 0x7D, 0x0D, 0x0A, 0x30, 0x78, 0x34, 0x39, 0x39, 0x41, 0x46, 0x41, 0x33, 0x38, 0x3A, 0x7B, 0x22, 0x43, 0x6F, 0x6E, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x54, 0x69, 0x6D, 0x65, 0x22, 0x7D, 0x3D, 0x55, 0x69, 0x6E, 0x74, 0x38, 0x3A, 0x30, 0x3A, 0x7B, 0x30, 0x78, 0x31, 0x30, 0x7D, 0x0D, 0x0A, 0x30, 0x78, 0x34, 0x39, 0x42, 0x45, 0x44, 0x41, 0x33, 0x31, 0x3A, 0x7B, 0x22, 0x4D, 0x61, 0x78, 0x46, 0x69, 0x72, 0x65, 0x53, 0x74, 0x61, 0x67, 0x65, 0x22, 0x7D, 0x3D, 0x55, 0x69, 0x6E, 0x74, 0x38, 0x3A, 0x30, 0x3A, 0x7B, 0x30, 0x78, 0x30, 0x34, 0x7D, 0x0D, 0x0A, 0x30, 0x78, 0x36, 0x38, 0x45, 0x45, 0x39, 0x37, 0x36, 0x34, 0x3A, 0x7B, 0x22, 0x50, 0x6F, 0x6C, 0x6C, 0x75, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x52, 0x61, 0x64, 0x69, 0x75, 0x73, 0x22, 0x7D, 0x3D, 0x46, 0x6C, 0x6F, 0x61, 0x74, 0x33, 0x32, 0x3A, 0x34, 0x3A, 0x7B, 0x35, 0x2C, 0x35, 0x2C, 0x30, 0x2C, 0x30, 0x7D, 0x0D, 0x0A, 0x30, 0x78, 0x38, 0x41, 0x31, 0x43, 0x33, 0x45, 0x37, 0x32, 0x3A, 0x7B, 0x22, 0x57, 0x6F, 0x72, 0x74, 0x68, 0x22, 0x7D, 0x3D, 0x53, 0x69, 0x6E, 0x74, 0x36, 0x34, 0x3A, 0x30, 0x3A, 0x7B, 0x30, 0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x41, 0x39, 0x7D, 0x0D, 0x0A, 0x30, 0x78, 0x38, 0x43, 0x42, 0x33, 0x35, 0x31, 0x31, 0x46, 0x3A, 0x7B, 0x22, 0x4F, 0x63, 0x63, 0x75, 0x70, 0x61, 0x6E, 0x74, 0x20, 0x54, 0x79, 0x70, 0x65, 0x73, 0x22, 0x7D, 0x3D, 0x55, 0x69, 0x6E, 0x74, 0x33, 0x32, 0x3A, 0x31, 0x3A, 0x7B, 0x30, 0x78, 0x30, 0x30, 0x30, 0x30, 0x33, 0x31, 0x31, 0x30, 0x7D, 0x0D, 0x0A, 0x30, 0x78, 0x41, 0x41, 0x31, 0x44, 0x44, 0x33, 0x39, 0x36, 0x3A, 0x7B, 0x22, 0x4F, 0x63, 0x63, 0x75, 0x70, 0x61, 0x6E, 0x74, 0x47, 0x72, 0x6F, 0x75, 0x70, 0x73, 0x22, 0x7D, 0x3D, 0x55, 0x69, 0x6E, 0x74, 0x33, 0x32, 0x3A, 0x36, 0x3A, 0x7B, 0x30, 0x78, 0x30, 0x30, 0x30, 0x30, 0x31, 0x30, 0x30, 0x31, 0x2C, 0x30, 0x78, 0x30, 0x30, 0x30, 0x31, 0x33, 0x31, 0x31, 0x30, 0x2C, 0x30, 0x78, 0x30, 0x30, 0x30, 0x30, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x30, 0x78, 0x30, 0x30, 0x30, 0x30, 0x32, 0x30, 0x30, 0x31, 0x2C, 0x30, 0x78, 0x30, 0x30, 0x30, 0x30, 0x32, 0x30, 0x30, 0x32, 0x2C, 0x30, 0x78, 0x30, 0x30, 0x30, 0x30, 0x32, 0x30, 0x30, 0x33, 0x7D, 0x0D, 0x0A, 0x30, 0x78, 0x41, 0x41, 0x31, 0x44, 0x44, 0x33, 0x39, 0x37, 0x3A, 0x7B, 0x22, 0x53, 0x46, 0x58, 0x3A, 0x51, 0x75, 0x65, 0x72, 0x79, 0x20, 0x53, 0x6F, 0x75, 0x6E, 0x64, 0x22, 0x7D, 0x3D, 0x55, 0x69, 0x6E, 0x74, 0x33, 0x32, 0x3A, 0x30, 0x3A, 0x7B, 0x30, 0x78, 0x32, 0x41, 0x38, 0x39, 0x31, 0x36, 0x41, 0x42, 0x7D, 0x0D, 0x0A, 0x30, 0x78, 0x41, 0x41, 0x38, 0x33, 0x35, 0x35, 0x38, 0x46, 0x3A, 0x7B, 0x22, 0x43, 0x72, 0x61, 0x6E, 0x65, 0x20, 0x48, 0x69, 0x6E, 0x74, 0x73, 0x22, 0x7D, 0x3D, 0x55, 0x69, 0x6E, 0x74, 0x38, 0x3A, 0x30, 0x3A, 0x7B, 0x30, 0x78, 0x30, 0x30, 0x7D, 0x0D, 0x0A, 0x30, 0x78, 0x43, 0x38, 0x45, 0x44, 0x32, 0x44, 0x38, 0x34, 0x3A, 0x7B, 0x22, 0x57, 0x61, 0x74, 0x65, 0x72, 0x20, 0x43, 0x6F, 0x6E, 0x73, 0x75, 0x6D, 0x65, 0x64, 0x22, 0x7D, 0x3D, 0x55, 0x69, 0x6E, 0x74, 0x33, 0x32, 0x3A, 0x30, 0x3A, 0x7B, 0x30, 0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x39, 0x38, 0x7D, 0x0D, 0x0A, 0x30, 0x78, 0x45, 0x39, 0x31, 0x41, 0x30, 0x42, 0x35, 0x46, 0x3A, 0x7B, 0x22, 0x42, 0x75, 0x69, 0x6C, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x22, 0x7D, 0x3D, 0x53, 0x69, 0x6E, 0x74, 0x36, 0x34, 0x3A, 0x30, 0x3A, 0x7B, 0x30, 0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x36, 0x37, 0x38, 0x7D, 0x0D, 0x0A, 0x31, 0x2E, 0x35, 0x38, 0x39, 0x37, 0x39, 0x42, 0x2B, 0xF2, 0x55, 0xBF, 0xB7, 0x55 };

			//Sample data from Jim CarProp Pack 1.2.dat (blank exemplars)
			public static byte[] nullproperty = { 0x45, 0x51, 0x5A, 0x42, 0x31, 0x23, 0x23, 0x23, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
			public static byte[] nullproperty_extradata = { 0x45, 0x51, 0x5A, 0x42, 0x31, 0x23, 0x23, 0x23, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x57, 0xDF, 0x81, 0x70, 0x00, 0x49, 0x00 };
		}

		// 00x Misc Test Methods
		[TestClass]
		public class _00x_MiscTests {

		}

		// 01x Test Methods for DBPFUtil class
		[TestClass]
		public class _01x_DBPFUtil {
			[TestMethod]
			public void Test_010_DBPFUtil_IsFileDBPF() {
				Assert.IsTrue(DBPFUtil.IsValidDBPF("C:\\Users\\Administrator\\Documents\\SimCity 4\\Plugins\\z_GraphModd. V2.dat"));
				Assert.IsTrue(DBPFUtil.IsValidDBPF("C:\\Program Files (x86)\\Steam\\steamapps\\common\\SimCity 4 Deluxe\\Plugins\\CAS_AutoHistorical_v0.0.2.dat"));
				Assert.IsFalse(DBPFUtil.IsValidDBPF("C:\\Program Files (x86)\\Steam\\steamapps\\common\\SimCity 4 Deluxe\\Plugins\\CAS_AutoHistorical_v0.0.2.dll"));
				Assert.IsFalse(DBPFUtil.IsValidDBPF("C:\\Program Files (x86)\\Steam\\steamapps\\common\\SimCity 4 Deluxe\\Plugins\\Background3D0.png"));
				Assert.IsTrue(DBPFUtil.IsValidDBPF("C:\\Users\\Administrator\\Documents\\SimCity 4\\Plugins\\!Deps 2\\PLOP_1x1_blank_602135f4.SC4Lot"));
			}

			[TestMethod]
			public void Test_011_DBPFUtil_ReverseBytes() {
				//Example: 1697917002 (0x 65 34 28 4A) returns 1244148837 (0x 4A 28 34 65)
				Assert.AreEqual((uint) 1244148837, DBPFUtil.ReverseBytes(1697917002));
				Assert.AreEqual((uint) 0x4a283465, DBPFUtil.ReverseBytes(0x6534284a));
				Assert.AreEqual((uint) 0, DBPFUtil.ReverseBytes(0));

				Assert.AreEqual(0x7FFFFFFFFFFF0000, DBPFUtil.ReverseBytes(0x0000FFFFFFFFFF7F));
			}

			[TestMethod]
			public void Test_012_DBPFUtil_UintToHexString() {
				Assert.AreEqual("6534284A", DBPFUtil.UIntToHexString(1697917002, 8));
				Assert.AreEqual("4A283465", DBPFUtil.UIntToHexString(1244148837, 8));
				Assert.AreEqual("6534284A", DBPFUtil.UIntToHexString(0x6534284A, 8));
				Assert.AreEqual("4A283465", DBPFUtil.UIntToHexString(0x4A283465, 8));
				Assert.AreEqual("4D2", DBPFUtil.UIntToHexString(1234, 3));
				Assert.AreEqual("000004D2", DBPFUtil.UIntToHexString(1234, 8));
			}

			//[Ignore]
			[TestMethod]
			public void Test_013_DBPFUtil_StringFromByteArray() {
				byte[] dbpfB = new byte[] { 0x44, 0x42, 0x50, 0x46 };
				byte[] dbpfB1 = new byte[] { 68, 66, 80, 70 };
				Assert.AreEqual("DBPF", ByteArrayHelper.ToAString(dbpfB));
				Assert.AreEqual(ByteArrayHelper.ToAString(dbpfB), ByteArrayHelper.ToAString(dbpfB1));
				Assert.AreEqual("DBPF", ByteArrayHelper.ToAString(dbpfB, 0));
				Assert.AreEqual("DBPF", ByteArrayHelper.ToAString(dbpfB, 0, dbpfB.Length));
				Assert.AreEqual("BPF", ByteArrayHelper.ToAString(dbpfB, 1));
				Assert.AreEqual("DB", ByteArrayHelper.ToAString(dbpfB, 0, 2));
				Assert.AreEqual("P", ByteArrayHelper.ToAString(dbpfB, 2, 1));


				string lettersS = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
				byte[] lettersB = new byte[] { 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A };
				Assert.AreEqual(lettersS, ByteArrayHelper.ToAString(lettersB));

				string numbersS = "01213456789";
				byte[] numbersB = new byte[] { 0x30, 0x31, 0x32, 0x31, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39 };
				Assert.AreEqual(numbersS, ByteArrayHelper.ToAString(numbersB));

				string specialS = "~`!@#$%^&*()_+-=[]\\{}|;':\",./<>?";
				byte[] specialB = new byte[] { 0x7E, 0x60, 0x21, 0x40, 0x23, 0x24, 0x25, 0x5E, 0x26, 0x2A, 0x28, 0x29, 0x5F, 0x2B, 0x2D, 0x3D, 0x5B, 0x5D, 0x5C, 0x7B, 0x7D, 0x7C, 0x3B, 0x27, 0x3A, 0x22, 0x2C, 0x2E, 0x2F, 0x3C, 0x3E, 0x3F };
				Assert.AreEqual(specialS, ByteArrayHelper.ToAString(specialB));

				Assert.AreEqual(null,ByteArrayHelper.ToAString(null));
			}

			[TestMethod]
			public void Test_014_DBPFUtil_StringToByteArray() {
				string s1 = "Test";
				byte[] b1 = { 0x54, 0x65, 0x73, 0x74 };
				string s2 = "Parks Aura";
				byte[] b2 = { 0x50, 0x61, 0x72, 0x6b, 0x73, 0x20, 0x41, 0x75, 0x72, 0x61 };
				CollectionAssert.AreEqual(b1, ByteArrayHelper.ToByteArray(s1));
				CollectionAssert.AreEqual(b2, ByteArrayHelper.ToByteArray(s2));
			}

			[TestMethod]
			public void Test_015_DBPFUtil_DateFromUnix() {
				uint u1 = 0x5e115977; // 1/5/2020 3:35:19 AM 
				DateTime d1 = new DateTime(2020, 1, 5, 3, 35, 19);
				uint u2 = 0x60557b29; // 3/20/2021 4:33:45 AM
				DateTime d2 = new DateTime(2021, 3, 20, 4, 33, 45);

				Assert.AreEqual(d1, DBPFUtil.UnixToDate(u1));
				Assert.AreEqual(d2, DBPFUtil.UnixToDate(u2));
			}
		}

		// 02x Test methods for DBPFCompression class
		[TestClass]
		public class _02x_DBPFCompression {

			[TestMethod]
			public void Test_020_DBPFCompression_IsCompressed() {
				Assert.IsTrue(DBPFCompression.IsCompressed(TestArrays.compresseddata_b));
				Assert.IsFalse(DBPFCompression.IsCompressed(TestArrays.notcompresseddata_b));
				Assert.IsFalse(DBPFCompression.IsCompressed(TestArrays.decompresseddata_b));
			}

			[TestMethod]
			public void Test_021_DBPFCompression_GetDecompressedSize() {
				Assert.AreEqual((uint) 44, DBPFCompression.GetDecompressedSize(TestArrays.notcompresseddata_b));
				Assert.AreEqual((uint) 446, DBPFCompression.GetDecompressedSize(TestArrays.compresseddata_b));
				Assert.AreEqual((uint) 446, DBPFCompression.GetDecompressedSize(TestArrays.decompresseddata_b)); //BUG - figure out why this returns 318 when read from the index below
			}

			[TestMethod]
			public void Test_025_DBPFCompression_Decompress() {
				CollectionAssert.AreEqual(TestArrays.notcompresseddata_b, DBPFCompression.Decompress(TestArrays.notcompresseddata_b));
				CollectionAssert.AreEqual(TestArrays.decompresseddata_b, DBPFCompression.Decompress(TestArrays.compresseddata_b));
			}
		}

		// 03x Test Methods for ByteArrayHelper class
		[TestClass]
		public class _03x_ByteArrayHelper {
			//Remember here that we are not "reading" the bytes straight from the file in order; rather we are "getting" numbers from them so we are worried about endianness.
			readonly byte[] bytes = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x99, 0x70, 0x01, 0x00, 0x00, 0x00, 0x3C, 0x53, 0xBC, 0x70, 0x0C, 0x00, 0x00, 0x00, 0x3C, 0x53, 0xBC, 0x70 };
			readonly byte[] bytesAsBools = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01 };
			readonly bool[] bools = { false, false, false, false, false, false, true, true, true, false, false, false, true, true, true, true, true, false, false, false, true, true, true, true };
			readonly ushort[] uint16 = { 0x0000, 0x0000, 0000, 0x7099, 0x0001, 0x0000, 0x533C, 0x70BC, 0x000C, 0x0000, 0x533C, 0x70BC };
			readonly int[] sint32 = { 0x00000000, 0x70990000, 0x00000001, 0x70BC533C, 0x0000000C, 0x70BC533C };
			readonly float[] float32 = { 0f, 3.78809652e+29f, 1.401298e-45f, 4.66270448e+29f, 1.681558e-44f, 4.66270448e+29f };
			readonly uint[] uint32 = { 0x00000000, 0x70990000, 0x00000001, 0x70BC533C, 0x0000000C, 0x70BC533C };
			readonly long[] sint64 = { 0x7099000000000000, 0x70BC533C00000001, 0x70BC533C0000000C };
			//TODO - should add unit tests to test edge cases - min and max values

			[TestMethod]
			public void Test_030_ByteArrayHelper_ToTypeArray() {
				CollectionAssert.AreEqual(bools, ByteArrayHelper.ToBoolArray(bytesAsBools));
				CollectionAssert.AreEqual(bytes, ByteArrayHelper.ToUint8Array(bytes));
				CollectionAssert.AreEqual(uint16, ByteArrayHelper.ToUInt16Array(bytes));
				CollectionAssert.AreEqual(sint32, ByteArrayHelper.ToSInt32Array(bytes));
				CollectionAssert.AreEqual(float32, ByteArrayHelper.ToFloat32Array(bytes));
				CollectionAssert.AreEqual(uint32, ByteArrayHelper.ToUInt32Array(bytes));
				CollectionAssert.AreEqual(sint64, ByteArrayHelper.ToSInt64Array(bytes));
			}

			[TestMethod]
			public void Test_031_ByteArrayHelper_ToByteArray() {
				CollectionAssert.AreEqual(bytesAsBools, ByteArrayHelper.ToByteArray(bools));
				CollectionAssert.AreEqual(bytes, ByteArrayHelper.ToByteArray(uint16));
				CollectionAssert.AreEqual(bytes, ByteArrayHelper.ToByteArray(sint32));
				CollectionAssert.AreEqual(bytes, ByteArrayHelper.ToByteArray(float32));
				CollectionAssert.AreEqual(bytes, ByteArrayHelper.ToByteArray(uint32));
				CollectionAssert.AreEqual(bytes, ByteArrayHelper.ToByteArray(sint64));
			}

			[TestMethod]
			public void Test_032_ByteArrayHelper_ReadAUint() {
				byte[] dbpf = { 0x44, 0x42, 0x50, 0x46 };
				Assert.AreEqual((uint) 0x44425046, ByteArrayHelper.ReadBytesIntoUint(dbpf));
				byte[] arr1 = { 0x00, 0x00, 0x10, 0x00 };
				Assert.AreEqual((uint) 0x00001000, ByteArrayHelper.ReadBytesIntoUint(arr1));
				byte[] arr2 = { 0x07, 0x00, 0x00, 0x30 };
				Assert.AreEqual((uint) 0x07000030, ByteArrayHelper.ReadBytesIntoUint(arr2));
			}
		}

		// 05x Test Methods for DBPFTGI Class
		[TestClass]
		public class _05x_DBPFTGI {
			[TestMethod]
			public void Test_050_DBPFTGI_CreateNew() {

			}

			[TestMethod]
			public void Test_052_DBPFTGI_Equals() {
				DBPFTGI tgi1 = new DBPFTGI(0, 0, 0);
				DBPFTGI tgi2 = new DBPFTGI(0, 0, 0);
				DBPFTGI tgi3 = new DBPFTGI(0xe86b1eef, 0xe86b1eef, 0x286b1f03);
				DBPFTGI tgi4 = new DBPFTGI(3899334383, 3899334383, 678108931);
				Assert.AreEqual(tgi1, tgi2);
				Assert.IsTrue(tgi1.Equals(tgi2));
				Assert.IsTrue(tgi2.Equals(tgi1));
				Assert.AreEqual(tgi3, tgi4);
				Assert.IsTrue(tgi3.Equals(tgi4));
				Assert.IsTrue(tgi4.Equals(tgi3));

				Assert.AreNotEqual(tgi2, tgi3);
				Assert.IsFalse(tgi1.Equals(tgi3));
				Assert.IsFalse(tgi3.Equals(tgi1));

				Assert.IsFalse(tgi1.Equals("string"));
				DBPFEntry e1 = new DBPFEntry(tgi1, 0, 0, 0);
				Assert.IsFalse(tgi1.Equals(e1));
			}

			[TestMethod]
			public void Test_054_DBPFTGI_MatchesKnownTGI() {
				//If called from a TGI object
				DBPFTGI tgi_blank = new DBPFTGI(0, 0, 0);
				DBPFTGI tgi_exemplar = new DBPFTGI(0x6534284a, 0, 0);
				DBPFTGI tgi_exemplarRail = new DBPFTGI(0x6534284a, 0xe8347989, 0);
				DBPFTGI tgi_exemplarRail2 = new DBPFTGI(0x6534284a, 0xe8347989, 0x1ab4e56a);

				Assert.IsTrue(tgi_blank.MatchesKnownTGI(DBPFTGI.BLANKTGI));
				Assert.IsTrue(tgi_blank.MatchesKnownTGI(DBPFTGI.NULLTGI));

				Assert.IsTrue(tgi_exemplar.MatchesKnownTGI(DBPFTGI.EXEMPLAR));
				Assert.IsTrue(tgi_exemplarRail.MatchesKnownTGI(DBPFTGI.EXEMPLAR_RAIL));
				Assert.IsTrue(tgi_exemplarRail2.MatchesKnownTGI(DBPFTGI.EXEMPLAR_RAIL));
				Assert.IsTrue(tgi_exemplarRail2.MatchesKnownTGI(DBPFTGI.EXEMPLAR));
				Assert.IsFalse(tgi_exemplar.MatchesKnownTGI(DBPFTGI.COHORT));
				Assert.IsTrue(tgi_exemplar.MatchesKnownTGI(DBPFTGI.NULLTGI));
				Assert.IsFalse(tgi_exemplar.MatchesKnownTGI(DBPFTGI.PNG));


				//If called from an Entry object
				DBPFEntry entry_blank = new DBPFEntry(tgi_blank);
				DBPFEntry entry_exemplar = new DBPFEntry(tgi_exemplar);
				DBPFEntry entry_exemplarRail = new DBPFEntry(tgi_exemplarRail);
				DBPFEntry entry_exemplarRail2 = new DBPFEntry(tgi_exemplarRail2);

				Assert.IsTrue(entry_blank.MatchesKnownEntryType(DBPFTGI.BLANKTGI));
				Assert.IsTrue(entry_blank.MatchesKnownEntryType(DBPFTGI.NULLTGI));

				Assert.IsTrue(entry_exemplar.MatchesKnownEntryType(DBPFTGI.EXEMPLAR));
				Assert.IsTrue(entry_exemplarRail.MatchesKnownEntryType(DBPFTGI.EXEMPLAR_RAIL));
				Assert.IsTrue(entry_exemplarRail2.MatchesKnownEntryType(DBPFTGI.EXEMPLAR_RAIL));
				Assert.IsTrue(entry_exemplarRail2.MatchesKnownEntryType(DBPFTGI.EXEMPLAR));
				Assert.IsFalse(entry_exemplar.MatchesKnownEntryType(DBPFTGI.COHORT));
				Assert.IsTrue(entry_exemplar.MatchesKnownEntryType(DBPFTGI.NULLTGI));
				Assert.IsFalse(entry_exemplar.MatchesKnownEntryType(DBPFTGI.PNG));
			}

			[TestMethod]
			public void Test_055_DBPFTGI_MatchesAnyKnownTGI() {
				DBPFTGI tgi_blank = new DBPFTGI(0, 0, 0);
				DBPFTGI tgi_exemplar = new DBPFTGI(0x6534284a, 0, 0);
				DBPFTGI tgi_exemplarRail = new DBPFTGI(0x6534284a, 0xe8347989, 0);
				DBPFTGI tgi_exemplarRail2 = new DBPFTGI(0x6534284a, 0xe8347989, 0x1ab4e56a);
				DBPFTGI tgi_PNG_Icon = new DBPFTGI(0x856ddbac, 0x6a386d26, 0x1ab4e56f);
				DBPFTGI tgi_PNG = new DBPFTGI(0x856ddbac, 0x6a386d27, 0x1ab4e56f);
				Assert.AreEqual("BLANKTGI", tgi_blank.MatchesAnyKnownTGI());
				Assert.AreEqual("EXEMPLAR", tgi_exemplar.MatchesAnyKnownTGI());
				Assert.AreEqual("EXEMPLAR_RAIL", tgi_exemplarRail.MatchesAnyKnownTGI());
				Assert.AreEqual("EXEMPLAR_RAIL", tgi_exemplarRail2.MatchesAnyKnownTGI());
				Assert.AreEqual("PNG_ICON", tgi_PNG_Icon.MatchesAnyKnownTGI());
				Assert.AreEqual("PNG", tgi_PNG.MatchesAnyKnownTGI());
			}

			[TestMethod]
			public void Test_056a_DBPFTGI_ModifyTGIusingDBPFTGI() {
				DBPFTGI exemplar = new DBPFTGI(0x6534284a, 0, 0);
				DBPFTGI exemplar2 = exemplar.ModifyTGI(DBPFTGI.EXEMPLAR_AVENUE);
				Assert.AreEqual("0x6534284A, 0xCB730FAC, 0x00000000", exemplar2.ToString());
				Assert.AreEqual(exemplar.ToString(), exemplar.ModifyTGI(DBPFTGI.NULLTGI).ToString());
				DBPFTGI exemplar4 = new DBPFTGI(0, 2, 3);
				Assert.AreEqual("0xCA63E2A3, 0x4A5E8EF6, 0x00000003", exemplar4.ModifyTGI(DBPFTGI.LUA).ToString());
			}

			[TestMethod]
			public void Test_056b_DBPFTGI_ModifyTGIusingUint() {
				DBPFTGI exemplar = new DBPFTGI(0x6534284a, 0, 1000001);
				Assert.AreEqual("0x6534284A, 0x00000000, 0x00000064", exemplar.ModifyTGI(null, null, 100).ToString());
				Assert.AreEqual("0x00000064, 0x00000064, 0x00000064", exemplar.ModifyTGI(100, 100, 100).ToString());
			}
		}

		// 06x Test Methods for DBPFProperty Class
		[TestClass]
		public class _06x_DBPFProperty {
			[TestMethod]
			public void Test_060a_DBPFPropertyDataType_ReturnType() {
				Assert.AreEqual("SINT32", DBPFPropertyDataType.SINT32.Name);
				Assert.AreEqual(DBPFPropertyDataType.BOOL, DBPFPropertyDataType.LookupDataType(0xB00));
				Assert.AreEqual(DBPFPropertyDataType.UINT32.Name, DBPFPropertyDataType.LookupDataType(0x300).Name);
				Assert.AreEqual(4, DBPFPropertyDataType.LookupDataType(0x300).Length);
			}

			[TestMethod]
			public void Test_060b_DBPFPropertyDataType_ReturnDataType() {
				string a = "";
				Assert.AreEqual(a.GetType(), DBPFPropertyDataType.STRING.PrimitiveDataType);
				uint b = 0x0;
				Assert.AreEqual(b.GetType(), DBPFPropertyDataType.UINT32.PrimitiveDataType);
				byte c = 0x08;
				Assert.AreEqual(c.GetType(), DBPFPropertyDataType.UINT8.PrimitiveDataType);
			}

			[TestMethod]
			public void Test_061a_DBPFPropertyString_Binary() {
				byte[] byteparks = { 0x50, 0x61, 0x72, 0x6B, 0x73 };
				string stringparks = "Parks";
				byte[] byteparksaura = { 0x50, 0x61, 0x72, 0x6b, 0x73, 0x20, 0x41, 0x75, 0x72, 0x61 };
				string stringparksaura = "Parks Aura";
				byte[] bytedataviewparksaura = { 0x44, 0x61, 0x74, 0x61, 0x56, 0x69, 0x65, 0x77, 0x3A, 0x20, 0x50, 0x61, 0x72, 0x6B, 0x73, 0x20, 0x41, 0x75, 0x72, 0x61 };
				string stringdataviewparksaura = "DataView: Parks Aura";

				//Test a property read from file
				DBPFProperty propb = DBPFProperty.DecodeProperty(TestArrays.decompresseddata_b, 37);
				Assert.AreEqual((uint) 0x20, propb.ID);
				Assert.AreEqual((uint) 20, propb.NumberOfReps);
				Assert.AreEqual(DBPFPropertyDataType.STRING, propb.DataType);
				CollectionAssert.AreEqual(bytedataviewparksaura, propb.ByteValues);
				propb.DecodeValues();
				Assert.AreEqual(stringdataviewparksaura, propb.DecodedValues.GetValue(0));

				//Compare to known property
				DBPFProperty testProperty = new DBPFPropertyString() {
					ID = 0x20,
					NumberOfReps = 20,
					ByteValues = ByteArrayHelper.ToByteArray(stringdataviewparksaura)
				};
				Assert.AreEqual(testProperty.ID, propb.ID);
				Assert.AreEqual(testProperty.NumberOfReps, propb.NumberOfReps);
				Assert.AreEqual(testProperty.DataType, propb.DataType);
				CollectionAssert.AreEqual(testProperty.ByteValues, propb.ByteValues);
				propb.DecodeValues();
				testProperty.DecodeValues();
				CollectionAssert.AreEqual(testProperty.DecodedValues, propb.DecodedValues);

				//Check for no differences between values and valuesDecoded when each is changed
				testProperty.ByteValues = ByteArrayHelper.ToByteArray(stringparks);
				testProperty.NumberOfReps = 5;
				CollectionAssert.AreEqual(byteparks, testProperty.ByteValues);
				Assert.AreEqual((uint) byteparks.Length, testProperty.NumberOfReps);
				testProperty.ByteValues = byteparksaura;
				testProperty.NumberOfReps = 10;
				testProperty.DecodeValues();
				Assert.AreEqual(stringparksaura, testProperty.DecodedValues.GetValue(0));
				Assert.AreEqual((uint) stringparksaura.Length, testProperty.NumberOfReps);
			}

			[TestMethod]
			public void Test_061b_DBPFPropertyNumber_Binary() {
				//Single UInt32 value
				byte[] val = { 0x23, 0x00, 0x00, 0x00 };
				uint[] decoded = { 0x00000023 };
				DBPFProperty prop_file = DBPFProperty.DecodeProperty(TestArrays.decompresseddata_b);
				Assert.AreEqual((uint) 0x10, prop_file.ID);
				Assert.AreEqual((uint) 0, prop_file.NumberOfReps);
				Assert.AreEqual(DBPFPropertyDataType.UINT32, prop_file.DataType);
				CollectionAssert.AreEqual(val, prop_file.ByteValues);
				prop_file.DecodeValues();
				CollectionAssert.AreEqual(decoded, prop_file.DecodedValues);

				//7 repetitions of 0 (for 8 total values of 8)
				byte[] val2 = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
				uint[] decoded2 = { 0, 0, 0, 0, 0, 0, 0, 0 };
				prop_file = DBPFProperty.DecodeProperty(TestArrays.decompresseddata_b, 70);
				Assert.AreEqual((uint) 0x4A0B47E0, prop_file.ID);
				Assert.AreEqual((uint) 8, prop_file.NumberOfReps);
				Assert.AreEqual(DBPFPropertyDataType.UINT32, prop_file.DataType);
				CollectionAssert.AreEqual(val2, prop_file.ByteValues);
				prop_file.DecodeValues();
				CollectionAssert.AreEqual(decoded2, prop_file.DecodedValues);

				//True boolean value
				byte[] val3 = { 1 };
				bool[] decoded3 = { true };
				prop_file = DBPFProperty.DecodeProperty(TestArrays.decompresseddata_b, 115);
				Assert.AreEqual((uint) 0x4A0B47E1, prop_file.ID);
				Assert.AreEqual((uint) 0, prop_file.NumberOfReps);
				Assert.AreEqual(DBPFPropertyDataType.BOOL, prop_file.DataType);
				CollectionAssert.AreEqual(val3, prop_file.ByteValues);
				prop_file.DecodeValues();
				CollectionAssert.AreEqual(decoded3, prop_file.DecodedValues);

				//False boolean value
				byte[] val4 = { 0 };
				bool[] decoded4 = { false };
				prop_file = DBPFProperty.DecodeProperty(TestArrays.decompresseddata_b, 125);
				Assert.AreEqual((uint) 0x4A0B47E2, prop_file.ID);
				Assert.AreEqual((uint) 0, prop_file.NumberOfReps);
				Assert.AreEqual(DBPFPropertyDataType.BOOL, prop_file.DataType);
				CollectionAssert.AreEqual(val4, prop_file.ByteValues);
				prop_file.DecodeValues();
				CollectionAssert.AreEqual(decoded4, prop_file.DecodedValues);

				//Single UInt32 value of 0
				byte[] val5 = { 0, 0, 0, 0 };
				uint[] decoded5 = { 0 };
				prop_file = DBPFProperty.DecodeProperty(TestArrays.decompresseddata_b, 135);
				Assert.AreEqual((uint) 0x4A0B47E3, prop_file.ID);
				Assert.AreEqual((uint) 0, prop_file.NumberOfReps);
				Assert.AreEqual(DBPFPropertyDataType.UINT32, prop_file.DataType);
				CollectionAssert.AreEqual(val5, prop_file.ByteValues);
				prop_file.DecodeValues();
				CollectionAssert.AreEqual(decoded5, prop_file.DecodedValues);

				//28 UInt32s
				byte[] val6 = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x99, 0x70, 0x01, 0x00, 0x00, 0x00, 0x3C, 0x53, 0xBC, 0x70, 0x0C, 0x00, 0x00, 0x00, 0x3C, 0x53, 0xBC, 0x70, 0x0D, 0x00, 0x00, 0x00, 0x79, 0x8C, 0xD9, 0x70, 0x46, 0x00, 0x00, 0x00, 0x79, 0x8C, 0xD9, 0x70, 0x7F, 0x00, 0x00, 0x00, 0xBA, 0xC5, 0xF0, 0x70, 0x80, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x70, 0x81, 0x00, 0x00, 0x00, 0xDD, 0xF1, 0xE2, 0x70, 0xB8, 0x00, 0x00, 0x00, 0xBB, 0xE3, 0xC5, 0x70, 0xB9, 0x00, 0x00, 0x00, 0x9A, 0xD4, 0xA8, 0x70, 0xF2, 0x00, 0x00, 0x00, 0x79, 0xC6, 0x8A, 0x70, 0xF3, 0x00, 0x00, 0x00, 0x58, 0xB7, 0x6A, 0x70, 0xFE, 0x00, 0x00, 0x00, 0x36, 0xA8, 0x46, 0x70, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x99, 0x00, 0x70 };
				uint[] decoded6 = { 0x00000000, 0x70990000, 0x00000001, 0x70BC533C, 0x0000000C, 0x70BC533C, 0x0000000D, 0x70D98C79, 0x00000046, 0x70D98C79, 0x0000007F, 0x70F0C5BA, 0x00000080, 0x70FFFFFF, 0x00000081, 0x70E2F1DD, 0x000000B8, 0x70C5E3BB, 0x000000B9, 0x70A8D49A, 0x000000F2, 0x708AC679, 0x000000F3, 0x706AB758, 0x000000FE, 0x7046A836, 0x000000FF, 0x70009900 };
				prop_file = DBPFProperty.DecodeProperty(TestArrays.decompresseddata_b, 148);
				Assert.AreEqual((uint) 0x4A0B47E4, prop_file.ID);
				Assert.AreEqual((uint) 28, prop_file.NumberOfReps);
				Assert.AreEqual(DBPFPropertyDataType.UINT32, prop_file.DataType);
				CollectionAssert.AreEqual(val6, prop_file.ByteValues);
				prop_file.DecodeValues();
				CollectionAssert.AreEqual(decoded6, prop_file.DecodedValues);

				//Set values
				prop_file.ByteValues = val5;
				prop_file.NumberOfReps = 0;
				Assert.AreEqual((uint) 0, prop_file.NumberOfReps);
				CollectionAssert.AreEqual(val5, prop_file.ByteValues);
				prop_file.DecodeValues();
				CollectionAssert.AreEqual(decoded5, prop_file.DecodedValues);
				prop_file.ByteValues = val6;
				prop_file.NumberOfReps = 28;
				Assert.AreEqual((uint) 28, prop_file.NumberOfReps);
				CollectionAssert.AreEqual(val6, prop_file.ByteValues);
				prop_file.DecodeValues();
				CollectionAssert.AreEqual(decoded6, prop_file.DecodedValues);
			}

			[TestMethod]
			public void Test_062b_DBPFProperty_Text() {
				//1x Uint32
				DBPFProperty propt = DBPFProperty.DecodeProperty(TestArrays.notcompresseddata_t);
				Assert.AreEqual(DBPFPropertyDataType.UINT32, propt.DataType);
				Assert.AreEqual((uint) 0, propt.NumberOfReps);
				uint[] decoded = { 0x2 };
				propt.DecodeValues();
				CollectionAssert.AreEqual(decoded, propt.DecodedValues);

				//1x String
				string string2 = "B62-CS$_Albertsons_60s_Grocery v 1.1";
				DBPFProperty propt2 = DBPFProperty.DecodeProperty(TestArrays.notcompresseddata_t, 137);
				Assert.AreEqual(DBPFPropertyDataType.STRING, propt2.DataType);
				Assert.AreEqual((uint) 1, propt2.NumberOfReps);
				propt2.DecodeValues();
				Assert.AreEqual(string2, propt2.DecodedValues.GetValue(0));

				//1x Sint64
				DBPFProperty propt3 = DBPFProperty.DecodeProperty(TestArrays.notcompresseddata_t, 217);
				Assert.AreEqual(DBPFPropertyDataType.SINT64, propt3.DataType);
				Assert.AreEqual((uint) 0, propt3.NumberOfReps);
				long[] decoded3 = { 0x00000000000000A9 };
				propt3.DecodeValues();
				CollectionAssert.AreEqual(decoded3, propt3.DecodedValues);

				//3x Float32
				DBPFProperty propt4 = DBPFProperty.DecodeProperty(TestArrays.notcompresseddata_t, 277);
				Assert.AreEqual(DBPFPropertyDataType.FLOAT32, propt4.DataType);
				Assert.AreEqual((uint) 3, propt4.NumberOfReps);
				float[] decoded4 = { 81.589798f, 13.947300f, 39.442501f };
				propt4.DecodeValues();
				CollectionAssert.AreEqual(decoded4, propt4.DecodedValues);

				//1x Float32
				DBPFProperty propt5 = DBPFProperty.DecodeProperty(TestArrays.notcompresseddata_t, 355);
				Assert.AreEqual(DBPFPropertyDataType.FLOAT32, propt5.DataType);
				Assert.AreEqual((uint) 1, propt5.NumberOfReps);
				float[] decoded5 = { 0.5f };
				propt5.DecodeValues();
				CollectionAssert.AreEqual(decoded5, propt5.DecodedValues);

				//1x Uint8
				DBPFProperty propt6 = DBPFProperty.DecodeProperty(TestArrays.notcompresseddata_t, 472);
				Assert.AreEqual(DBPFPropertyDataType.UINT8, propt6.DataType);
				Assert.AreEqual((uint) 0, propt6.NumberOfReps);
				byte[] decoded6 = { 0x01 };
				propt6.DecodeValues();
				CollectionAssert.AreEqual(decoded6, propt6.DecodedValues);

				//4x Sint32
				DBPFProperty propt7 = DBPFProperty.DecodeProperty(TestArrays.notcompresseddata_t, 617);
				Assert.AreEqual(DBPFPropertyDataType.SINT32, propt7.DataType);
				Assert.AreEqual((uint) 4, propt7.NumberOfReps);
				int[] decoded7 = { 0x07, 0x03, 0x16, 0x00 };
				propt7.DecodeValues();
				CollectionAssert.AreEqual(decoded7, propt7.DecodedValues);

				//6x Uint32
				DBPFProperty propt8 = DBPFProperty.DecodeProperty(TestArrays.notcompresseddata_t, 1170);
				Assert.AreEqual(DBPFPropertyDataType.UINT32, propt8.DataType);
				Assert.AreEqual((uint) 6, propt8.NumberOfReps);
				uint[] decoded8 = { 0x1001, 0x13110, 0x2000, 0x2001, 0x2002, 0x2003 };
				propt8.DecodeValues();
				CollectionAssert.AreEqual(decoded8, propt8.DecodedValues);


				//TODO - text property parsing: remaining single: Sint32, , , Bool, , , UInt16,
				//TODO - text property parsing: remaining multis: , , , Bool, UInt8, SInt64, UInt16,
			}

			[TestMethod]
			public void Text_062_DBPFProperty_DecodeNoProperties() {
				DBPFProperty prop = DBPFProperty.DecodeProperty(TestArrays.nullproperty);
				Assert.AreEqual(null, prop);

				prop = DBPFProperty.DecodeProperty(TestArrays.nullproperty_extradata);
				Assert.AreEqual(null, prop);
			}


			[TestMethod]
			public void Test_06x_DBPFProperty_UseDataType() {
				DBPFProperty prop = DBPFProperty.DecodeProperty(TestArrays.decompresseddata_b);
				prop.DecodeValues();
				Type t = prop.DecodedValues.GetType().GetElementType();
				Array a = Array.CreateInstance(t, prop.NumberOfReps);
				uint b = 0;
				Assert.AreEqual(b.GetType(), a.GetType().GetElementType());
				Assert.AreEqual(t, a.GetType().GetElementType());
			}
		}

		// 07x Test Methods for Property XML Parsing
		[TestClass]
		public class _07x_XMLPropertyParsing {
			//[TestMethod]
			//public void Test_070_DBPFProperty_GetXMLProperty() {
			//	XElement el = XMLProperties.GetXMLProperty(0x00000010);
			//	Assert.AreEqual("0x00000010", el.Attribute("ID").Value);
			//	Assert.AreEqual("Exemplar Type", el.Attribute("Name").Value);

			//	el = XMLProperties.GetXMLProperty(0x87cd6345);
			//	Assert.AreEqual("0x87cd6345", el.Attribute("ID").Value);
			//	Assert.AreEqual("R$$$ Proximity Effect", el.Attribute("Name").Value);

			//	el = XMLProperties.GetXMLProperty(0x8a2602bb);
			//	Assert.AreEqual("0x8a2602bb", el.Attribute("ID").Value);
			//	Assert.AreEqual("Item Button ID", el.Attribute("Name").Value);
			//	Assert.AreEqual("Uint32", el.Attribute("Type").Value);
			//	Assert.AreEqual("Y", el.Attribute("ShowAsHex").Value);
			//	Assert.AreEqual("0x00000000", el.Attribute("Default").Value);
			//}

			[TestMethod]
			public void Text_071_DBPFProperty_AllProperties() {
				//< PROPERTY Name = "Item Button ID" ID = "0x8a2602bb" Type = "Uint32" Default = "0x00000000" ShowAsHex = "Y" >
				XMLProperties.AllProperties.TryGetValue(0x8a2602bb, out XMLExemplarProperty exmp);
				Assert.AreEqual(0x8a2602bb, exmp.ID);
				Assert.AreEqual("Item Button ID", exmp.Name);
				Assert.AreEqual(DBPFPropertyDataType.UINT32, exmp.Type);
				Assert.AreEqual(true, exmp.ShowAsHex);
				CollectionAssert.AreEqual(new List<string> { "0x00000000" }, exmp.DefaultValue);
				Assert.AreEqual(null, exmp.MaxValue);

				//<PROPERTY Name="Path Offset Range for Peds" ID="0x29dd40c1" Type="Float32" Count="2" Default="-1 3" ShowAsHex="Y">
				XMLProperties.AllProperties.TryGetValue(0x29dd40c1, out XMLExemplarProperty exmp2);
				Assert.AreEqual((uint) 0x29dd40c1, exmp2.ID);
				Assert.AreEqual("Path Offset Range for Peds", exmp2.Name);
				Assert.AreEqual(DBPFPropertyDataType.FLOAT32, exmp2.Type);
				Assert.AreEqual(true, exmp2.ShowAsHex);
				CollectionAssert.AreEqual(new List<string> { "-1", "3" }, exmp2.DefaultValue);
				Assert.AreEqual((short) 2, exmp2.Count);

				//<PROPERTY Name="WaveMinTimeInState" ID="0x6932dc06" Type="Float32" Count="4" Default="12 0.230 0.5 2" ShowAsHex="Y">
				XMLProperties.AllProperties.TryGetValue(0x6932dc06, out XMLExemplarProperty exmp3);
				Assert.AreEqual((uint) 0x6932dc06, exmp3.ID);
				Assert.AreEqual("WaveMinTimeInState", exmp3.Name);
				Assert.AreEqual(DBPFPropertyDataType.FLOAT32, exmp3.Type);
				Assert.AreEqual(true, exmp3.ShowAsHex);
				CollectionAssert.AreEqual(new List<string> { "12", "0.230", "0.5", "2" }, exmp3.DefaultValue);
				Assert.AreEqual((short) 4, exmp3.Count);
				Assert.AreEqual(null, exmp3.Step);

				//<PROPERTY Name="Health Effectiveness vs. Distance Effect" ID="0x891b3ae6" Type="Float32" Count="-2" Default="0 100" MinValue="0" MaxValue="100" ShowAsHex="Y">
				XMLProperties.AllProperties.TryGetValue(0x891b3ae6, out XMLExemplarProperty exmp4);
				Assert.AreEqual(0x891b3ae6, exmp4.ID);
				Assert.AreEqual("Health Effectiveness vs. Distance Effect", exmp4.Name);
				Assert.AreEqual(DBPFPropertyDataType.FLOAT32, exmp4.Type);
				Assert.AreEqual(true, exmp4.ShowAsHex);
				CollectionAssert.AreEqual(new List<string> { "0", "100" }, exmp4.DefaultValue);
				Assert.AreEqual((short) -2, exmp4.Count);
				Assert.AreEqual("0", exmp4.MinValue);
				Assert.AreEqual("100", exmp4.MaxValue);
				Assert.AreEqual(null, exmp4.MaxLength);
			}

			[TestMethod]
			public void Text_072_XMLProperties_GetProperty() {
				Assert.AreEqual((uint) 0x10, XMLProperties.LookupPropertyID("Exemplar Type"));
				Assert.AreEqual((uint) 0x10, XMLProperties.LookupPropertyID("ExemplarType"));
				Assert.AreEqual((uint) 0x10, XMLProperties.LookupPropertyID("exemplar type"));
				Assert.AreEqual((uint) 0x10, XMLProperties.LookupPropertyID("EXEMPLARTYPE"));
				Assert.AreEqual((uint) 0x879d12e7, XMLProperties.LookupPropertyID("MaxSlopeAlongNetwork"));
				Assert.AreEqual((uint) 0, XMLProperties.LookupPropertyID("property not found"));
			}
		}

		// 1xx Test Methods for DBPFFile Class
		[TestClass]
		public class _1xx_DBPFFile {
			[TestMethod]
			public void Test_101_DBPFFile_ValidDBPF() {
				DBPFFile dbpf = DBPFFile.CreateIfValidDBPF("C:\\Users\\Administrator\\Documents\\SimCity 4\\Plugins\\z_DataView - Parks Aura.dat");
				Assert.AreEqual("DBPF", dbpf.Header.Identifier);
				Assert.AreEqual((uint) 1, dbpf.Header.MajorVersion);
				Assert.AreEqual((uint) 0, dbpf.Header.MinorVersion);
				Assert.AreEqual((uint) 7, dbpf.Header.IndexMajorVersion);
			}

			//[Ignore]
			[TestMethod]
			public void Test_102_DBPFFile_NotValidDBPF() {
				DBPFFile notdbpf = DBPFFile.CreateIfValidDBPF("C:\\Program Files (x86)\\Steam\\steamapps\\common\\SimCity 4 Deluxe\\Plugins\\CAS_AutoHistorical_v0.0.2.dll");
				Assert.AreEqual(null, notdbpf);
			}

			[TestMethod]
			public void Test_110a_DecodeExemplarEntries() {
				List<DBPFProperty> propertiesKnown = new List<DBPFProperty> {
					DBPFProperty.DecodeProperty(TestArrays.decompresseddata_b, 24),
					DBPFProperty.DecodeProperty(TestArrays.decompresseddata_b, 37),
					DBPFProperty.DecodeProperty(TestArrays.decompresseddata_b, 70),
					DBPFProperty.DecodeProperty(TestArrays.decompresseddata_b, 115),
					DBPFProperty.DecodeProperty(TestArrays.decompresseddata_b, 125),
					DBPFProperty.DecodeProperty(TestArrays.decompresseddata_b, 135),
					DBPFProperty.DecodeProperty(TestArrays.decompresseddata_b, 148),
					DBPFProperty.DecodeProperty(TestArrays.decompresseddata_b, 273),
					DBPFProperty.DecodeProperty(TestArrays.decompresseddata_b, 286),
					DBPFProperty.DecodeProperty(TestArrays.decompresseddata_b, 296),
					DBPFProperty.DecodeProperty(TestArrays.decompresseddata_b, 309),
					DBPFProperty.DecodeProperty(TestArrays.decompresseddata_b, 322),
					DBPFProperty.DecodeProperty(TestArrays.decompresseddata_b, 335),
					DBPFProperty.DecodeProperty(TestArrays.decompresseddata_b, 384),
					DBPFProperty.DecodeProperty(TestArrays.decompresseddata_b, 433)
				};

				DBPFEntry entry = new DBPFEntry(DBPFTGI.EXEMPLAR);
				entry.DecodeEntry(TestArrays.decompresseddata_b);
				for (int idx = 0; idx < propertiesKnown.Count; idx++) {
					DBPFProperty outk = entry.ListOfProperties[idx];
					DBPFProperty outr = entry.ListOfProperties[idx];
					Assert.AreEqual(outk.ID, outr.ID);
					Assert.AreEqual(outk.NumberOfReps, outr.NumberOfReps);
					Assert.AreEqual(outk.DataType, outr.DataType);
					Assert.AreEqual(outk.KeyType, outr.KeyType);
					CollectionAssert.AreEqual(outk.ByteValues, outr.ByteValues);
				}


				//TODO - add text encoding tests here
			}

			[TestMethod]
			public void Test_110b_ParseLTEXTEntries() {
				DBPFEntry entryb = new DBPFEntry(DBPFTGI.LTEXT);
				entryb.DecodeEntry(TestArrays.notcompresseddata_b);
				Assert.AreEqual("Parks Aura (by Cori)", ByteArrayHelper.ToAString(entryb.DecodedData));

				//TODO - add text encoding tests here
			}

			[TestMethod]
			public void Test_111_ParseAllEntries() {
				List<DBPFProperty> propertiesKnown = new List<DBPFProperty> {
					DBPFProperty.DecodeProperty(TestArrays.decompresseddata_b, 24),
					DBPFProperty.DecodeProperty(TestArrays.decompresseddata_b, 37),
					DBPFProperty.DecodeProperty(TestArrays.decompresseddata_b, 70),
					DBPFProperty.DecodeProperty(TestArrays.decompresseddata_b, 115),
					DBPFProperty.DecodeProperty(TestArrays.decompresseddata_b, 125),
					DBPFProperty.DecodeProperty(TestArrays.decompresseddata_b, 135),
					DBPFProperty.DecodeProperty(TestArrays.decompresseddata_b, 148),
					DBPFProperty.DecodeProperty(TestArrays.decompresseddata_b, 273),
					DBPFProperty.DecodeProperty(TestArrays.decompresseddata_b, 286),
					DBPFProperty.DecodeProperty(TestArrays.decompresseddata_b, 296),
					DBPFProperty.DecodeProperty(TestArrays.decompresseddata_b, 309),
					DBPFProperty.DecodeProperty(TestArrays.decompresseddata_b, 322),
					DBPFProperty.DecodeProperty(TestArrays.decompresseddata_b, 335),
					DBPFProperty.DecodeProperty(TestArrays.decompresseddata_b, 384),
					DBPFProperty.DecodeProperty(TestArrays.decompresseddata_b, 433)
				};

				DBPFFile dbpf = DBPFFile.CreateIfValidDBPF("C:\\Users\\Administrator\\Documents\\SimCity 4\\Plugins\\z_DataView - Parks Aura.dat");

				DBPFEntry entry0 = dbpf.ListOfEntries[0];
				entry0.DecodeEntry();
				for (int idx = 0; idx < propertiesKnown.Count; idx++) {
					DBPFProperty outk = propertiesKnown[idx];
					DBPFProperty outr = entry0.ListOfProperties[idx];
					Assert.AreEqual(outk.ID, outr.ID);
					Assert.AreEqual(outk.NumberOfReps, outr.NumberOfReps);
					Assert.AreEqual(outk.DataType, outr.DataType);
					Assert.AreEqual(outk.KeyType, outr.KeyType);
					CollectionAssert.AreEqual(outk.ByteValues, outr.ByteValues);
				}

				DBPFEntry entry1 = dbpf.ListOfEntries[1];
				entry1.DecodeEntry();
				Assert.AreEqual("Parks Aura (by Cori)", ByteArrayHelper.ToAString(entry1.DecodedData));

				DBPFEntry entry11 = dbpf.ListOfEntries[dbpf.ListOfEntries.Count - 2];
				entry11.DecodeEntry();
				Assert.AreEqual("+100  to +165", ByteArrayHelper.ToAString(entry11.DecodedData));
			}

			[Ignore]
			[TestMethod]
			public void Test_112_ParseBuildingExemplar() {
				DBPFFile dbpf = DBPFFile.CreateIfValidDBPF("C:\\Users\\Administrator\\OneDrive\\SC4 MODPACC\\B62\\B62-Albertsons 60's Retro v2.0\\b62-albertsons_60s v 1.1-0x6534284a-0xd3a3e650-0xd4ebfbfa.SC4Desc");
				List<DBPFEntry> entries = dbpf.ListOfEntries;
				DBPFEntry entry = entries[0];
				entry.DecodeEntry();

				//uint[] val = (uint[]) properties[0].DecodeValues();
				//Assert.AreEqual(DBPFProperty.ExemplarTypes.Building, val[0]);
			}
		}
	}
}
